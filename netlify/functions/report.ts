import type { Handler, HandlerEvent } from '@netlify/functions';
import { createClient } from '@supabase/supabase-js';
import { createHmac } from 'crypto';
import algosdk from 'algosdk';

// Environment variables
const SUPABASE_URL = process.env.VITE_SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const SENTRY_WEBHOOK_SECRET = process.env.SENTRY_WEBHOOK_SECRET!;
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY!;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY!;
const ELEVEN_API_KEY = process.env.ELEVEN_API_KEY!;
const ALGORAND_TOKEN = process.env.ALGORAND_TOKEN || '';
const ALGORAND_SERVER = process.env.ALGORAND_SERVER || 'https://testnet-api.algonode.cloud';
const ALGORAND_MNEMONIC = process.env.ALGORAND_MNEMONIC!;

// Initialize Supabase client with service role key for bypassing RLS
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Initialize Algorand client
const algodClient = new algosdk.Algodv2(ALGORAND_TOKEN, ALGORAND_SERVER, '');

interface SentryWebhookEvent {
  action: string;
  data: {
    issue: {
      id: string;
      title: string;
      culprit: string;
      level: string;
      status: string;
      statusDetails: any;
      type: string;
      metadata: any;
      numComments: number;
      assignedTo: any;
      permalink: string;
      firstSeen: string;
      lastSeen: string;
      count: string;
      userCount: number;
      project: {
        id: string;
        name: string;
        slug: string;
      };
    };
  };
  installation: {
    uuid: string;
  };
}

interface Project {
  id: string;
  name: string;
  user_id: string;
}

interface AIProvider {
  name: string;
  cost: number;
  execute: (prompt: string, context: any) => Promise<string>;
}

// Enhanced AI Provider implementations with better error handling and retry logic
const aiProviders: AIProvider[] = [
  {
    name: 'Google Gemini 2.0 Flash',
    cost: 0.0014,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GOOGLE_API_KEY}`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          contents: [{
            parts: [{
              text: `${prompt}\n\nIncident Data:\n${JSON.stringify(context, null, 2)}`
            }]
          }],
          generationConfig: {
            temperature: 0.3,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          },
          safetySettings: [
            {
              category: 'HARM_CATEGORY_HARASSMENT',
              threshold: 'BLOCK_NONE'
            },
            {
              category: 'HARM_CATEGORY_HATE_SPEECH',
              threshold: 'BLOCK_NONE'
            },
            {
              category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT',
              threshold: 'BLOCK_NONE'
            },
            {
              category: 'HARM_CATEGORY_DANGEROUS_CONTENT',
              threshold: 'BLOCK_NONE'
            }
          ]
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Google Gemini API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!content) {
        throw new Error('No content generated by Gemini');
      }
      
      return content;
    }
  },
  {
    name: 'OpenAI GPT-4o-mini',
    cost: 0.0021,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: prompt },
            { role: 'user', content: JSON.stringify(context, null, 2) },
          ],
          max_tokens: 2000,
          temperature: 0.3,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      
      if (!content) {
        throw new Error('No content generated by OpenAI');
      }
      
      return content;
    }
  },
  {
    name: 'Anthropic Claude 3 Haiku',
    cost: 0.00375,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${ANTHROPIC_API_KEY}`,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
          model: 'claude-3-haiku-20240307',
          max_tokens: 2000,
          temperature: 0.3,
          system: prompt,
          messages: [{
            role: 'user',
            content: JSON.stringify(context, null, 2)
          }]
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.content?.[0]?.text;
      
      if (!content) {
        throw new Error('No content generated by Claude');
      }
      
      return content;
    }
  }
];

const handler: Handler = async (event: HandlerEvent) => {
  // Only handle POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      headers: {
        'Allow': 'POST',
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ error: 'Method not allowed' }),
    };
  }

  try {
    // Verify Sentry webhook signature
    const signature = event.headers['x-sentry-hook-signature'];
    if (!signature) {
      console.error('Missing webhook signature');
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Missing signature' }),
      };
    }

    const body = event.body || '';
    const expectedSignature = createHmac('sha256', SENTRY_WEBHOOK_SECRET)
      .update(body)
      .digest('hex');

    if (signature !== expectedSignature) {
      console.error('Invalid webhook signature');
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid signature' }),
      };
    }

    const webhookData: SentryWebhookEvent = JSON.parse(body);
    
    // Only process issue events
    if (webhookData.action !== 'created' && webhookData.action !== 'resolved') {
      console.log(`Ignoring webhook action: ${webhookData.action}`);
      return {
        statusCode: 200,
        body: JSON.stringify({ message: 'Event ignored' }),
      };
    }

    const issue = webhookData.data.issue;
    
    // Find the project by Sentry project slug
    const { data: projects, error: projectError } = await supabase
      .from('projects')
      .select('*')
      .order('created_at', { ascending: false });

    if (projectError) {
      console.error('Error fetching projects:', projectError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error' }),
      };
    }

    if (!projects || projects.length === 0) {
      console.error('No projects found');
      return {
        statusCode: 404,
        body: JSON.stringify({ error: 'No projects configured' }),
      };
    }

    // For now, use the first project (in production, you'd match by org slug)
    const project: Project = projects[0];

    // Create initial report record
    const { data: report, error: insertError } = await supabase
      .from('reports')
      .insert({
        project_id: project.id,
        sentry_issue_id: issue.id,
        title: issue.title,
        markdown: 'Processing...',
        status: 'processing',
      })
      .select()
      .single();

    if (insertError || !report) {
      console.error('Failed to create report:', insertError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Failed to create report' }),
      };
    }

    // Process the incident asynchronously
    processIncident(project, issue, report.id).catch(error => {
      console.error('Async processing error:', error);
    });

    return {
      statusCode: 200,
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ 
        message: 'Webhook received, processing incident',
        reportId: report.id 
      }),
    };

  } catch (error) {
    console.error('Webhook processing error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      }),
    };
  }
};

async function processIncident(project: Project, issue: any, reportId: number) {
  let status: string = 'processing';
  let markdown = '';
  let algorandTx: string | null = null;
  let audioUrl: string | null = null;
  let usedProvider = '';

  try {
    console.log(`Processing incident ${issue.id} for project ${project.id}`);

    // Step 1: Fetch detailed issue information from Sentry (mock for now)
    const issueDetails = {
      ...issue,
      events: [], // In production, fetch recent events
      tags: [], // In production, fetch tags
      context: {} // In production, fetch context
    };
    
    // Step 2: Generate markdown summary using AI with fallback strategy
    const aiResult = await generateMarkdownSummaryWithFallback(issueDetails);
    markdown = aiResult.content;
    usedProvider = aiResult.provider;
    
    console.log(`Generated summary using ${usedProvider}`);
    
    // Step 3: Hash the markdown and anchor on Algorand
    try {
      algorandTx = await anchorOnAlgorand(markdown);
      console.log(`Anchored on Algorand: ${algorandTx}`);
    } catch (error) {
      console.error('Algorand anchoring failed:', error);
      status = 'pending_hash';
    }
    
    // Step 4: Generate audio summary
    try {
      audioUrl = await generateAudioSummary(markdown, reportId);
      console.log(`Generated audio summary: ${audioUrl}`);
    } catch (error) {
      console.error('Audio generation failed:', error);
      status = status === 'pending_hash' ? 'partial' : 'text_only';
    }
    
    // Step 5: Update report with results
    const finalStatus = status === 'processing' ? 'completed' : status;
    
    const { error: updateError } = await supabase
      .from('reports')
      .update({
        markdown,
        algorand_tx: algorandTx,
        audio_url: audioUrl,
        status: finalStatus,
      })
      .eq('id', reportId);

    if (updateError) {
      console.error('Error updating report:', updateError);
    }
    
    // Step 6: Send Slack notification (mock for now)
    try {
      await sendSlackNotification(project, issue, markdown, algorandTx, audioUrl, usedProvider);
      console.log('Slack notification sent');
    } catch (error) {
      console.error('Slack notification failed:', error);
    }
    
    console.log(`Successfully processed incident ${issue.id} with status ${finalStatus}`);
    
  } catch (error) {
    console.error('Processing failed:', error);
    
    // Update report with error status
    await supabase
      .from('reports')
      .update({
        markdown: markdown || `# Processing Failed\n\nAn error occurred while processing this incident:\n\n${error}`,
        status: 'failed',
      })
      .eq('id', reportId);
  }
}

async function generateMarkdownSummaryWithFallback(issueDetails: any): Promise<{ content: string; provider: string }> {
  const systemPrompt = `You are a senior SRE expert. Transform the following Sentry incident data into a polished post-mortem report in Markdown format. Include:

1. **Executive Summary** - Brief overview of the incident
2. **Timeline of Events** - Chronological sequence of what happened
3. **Root Cause Analysis** - Technical analysis of the underlying cause
4. **Impact Assessment** - User and business impact
5. **Resolution Steps** - What was done to resolve the issue
6. **Action Items for Prevention** - Concrete steps to prevent recurrence

Keep it professional, concise, and actionable. Use proper Markdown formatting with headers, lists, and code blocks where appropriate.`;

  // Try each AI provider in order until one succeeds
  for (let i = 0; i < aiProviders.length; i++) {
    const provider = aiProviders[i];
    
    try {
      console.log(`Attempting to generate summary with ${provider.name} (estimated cost: $${provider.cost})`);
      
      const content = await provider.execute(systemPrompt, issueDetails);
      
      console.log(`✅ Successfully generated summary with ${provider.name}`);
      return { content, provider: provider.name };
      
    } catch (error) {
      console.error(`❌ ${provider.name} failed:`, error);
      
      // If this is the last provider, throw the error
      if (i === aiProviders.length - 1) {
        throw new Error(`All AI providers failed. Last error from ${provider.name}: ${error}`);
      }
      
      // Otherwise, continue to the next provider
      console.log(`🔄 Falling back to next provider...`);
    }
  }
  
  // This should never be reached due to the throw above, but TypeScript needs it
  throw new Error('Unexpected error in AI fallback logic');
}

async function anchorOnAlgorand(markdown: string): Promise<string> {
  try {
    // Generate SHA-256 hash of the markdown
    const encoder = new TextEncoder();
    const data = encoder.encode(markdown);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

    // Recover account from mnemonic
    const account = algosdk.mnemonicToSecretKey(ALGORAND_MNEMONIC);
    
    // Get suggested transaction parameters
    const suggestedParams = await algodClient.getTransactionParams().do();
    
    // Create a 0-ALGO payment transaction with hash as note
    const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
      from: account.addr,
      to: account.addr, // Send to self for 0-amount anchoring
      amount: 0,
      note: new Uint8Array(Buffer.from(hashHex, 'hex')),
      suggestedParams,
    });

    // Sign the transaction
    const signedTxn = txn.signTxn(account.sk);
    
    // Submit the transaction
    const { txId } = await algodClient.sendRawTransaction(signedTxn).do();
    
    // Wait for confirmation
    await algosdk.waitForConfirmation(algodClient, txId, 4);
    
    console.log(`✅ Successfully anchored hash on Algorand: ${txId}`);
    return txId;
  } catch (error) {
    console.error('Algorand transaction failed:', error);
    throw error;
  }
}

async function generateAudioSummary(markdown: string, reportId: number): Promise<string> {
  try {
    // Extract key points from markdown for audio summary
    const audioText = markdown
      .replace(/#+\s/g, '') // Remove markdown headers
      .replace(/\*\*(.*?)\*\*/g, '$1') // Remove bold formatting
      .replace(/\*(.*?)\*/g, '$1') // Remove italic formatting
      .replace(/```[\s\S]*?```/g, '') // Remove code blocks
      .split('\n')
      .filter(line => line.trim() && !line.startsWith('- ') && !line.startsWith('*'))
      .slice(0, 10) // Limit to first 10 lines
      .join('. ')
      .substring(0, 500); // Limit to 500 characters for audio

    if (!audioText.trim()) {
      throw new Error('No suitable text found for audio generation');
    }

    // Generate audio using ElevenLabs
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM/stream`, {
      method: 'POST',
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': ELEVEN_API_KEY,
      },
      body: JSON.stringify({
        text: audioText,
        model_id: 'eleven_monolingual_v1',
        voice_settings: {
          stability: 0.5,
          similarity_boost: 0.5,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`ElevenLabs API error: ${response.status} - ${errorText}`);
    }

    // Get the audio stream
    const audioBuffer = await response.arrayBuffer();
    const audioFile = new Uint8Array(audioBuffer);
    
    // Upload to Supabase Storage
    const fileName = `report_${reportId}_${Date.now()}.mp3`;
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('audio-summaries')
      .upload(fileName, audioFile, {
        contentType: 'audio/mpeg',
        cacheControl: '3600',
      });

    if (uploadError) {
      throw new Error(`Supabase Storage error: ${uploadError.message}`);
    }

    // Get public URL
    const { data: urlData } = supabase.storage
      .from('audio-summaries')
      .getPublicUrl(fileName);

    console.log(`✅ Successfully generated and stored audio summary: ${urlData.publicUrl}`);
    return urlData.publicUrl;
  } catch (error) {
    console.error('Audio generation failed:', error);
    throw error;
  }
}

async function sendSlackNotification(
  project: Project,
  issue: any,
  markdown: string,
  algorandTx: string | null,
  audioUrl: string | null,
  usedProvider: string
) {
  // Mock Slack notification for now
  console.log('Slack notification would be sent with:', {
    project: project.name,
    issue: issue.title,
    provider: usedProvider,
    hasAudio: !!audioUrl,
    hasBlockchainProof: !!algorandTx
  });
  
  // In production, you would send to the actual Slack webhook URL
  // stored in the encrypted_secrets table
}

export { handler };