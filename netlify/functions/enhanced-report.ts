import type { Handler, HandlerEvent } from '@netlify/functions';
import { createClient } from '@supabase/supabase-js';
import { createHmac } from 'crypto';
import algosdk from 'algosdk';

// Environment variables
const SUPABASE_URL = process.env.VITE_SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const SENTRY_WEBHOOK_SECRET = process.env.SENTRY_WEBHOOK_SECRET!;
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY!;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY!;
const ELEVEN_API_KEY = process.env.ELEVEN_API_KEY!;
const ALGORAND_TOKEN = process.env.ALGORAND_TOKEN!;
const ALGORAND_SERVER = process.env.ALGORAND_SERVER || 'https://testnet-api.4160.nodely.io';
const ALGORAND_MNEMONIC = process.env.ALGORAND_MNEMONIC!;

// Initialize Supabase client
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Initialize Algorand client with Nodely headers
const algodClient = new algosdk.Algodv2(
  { 'X-Algo-api-token': ALGORAND_TOKEN }, // Nodely header format
  ALGORAND_SERVER,
  ''
);

interface SentryWebhookEvent {
  action: string;
  data: {
    issue: {
      id: string;
      title: string;
      culprit: string;
      level: string;
      status: string;
      statusDetails: any;
      type: string;
      metadata: any;
      numComments: number;
      assignedTo: any;
      permalink: string;
      firstSeen: string;
      lastSeen: string;
      count: string;
      userCount: number;
      project: {
        id: string;
        name: string;
        slug: string;
      };
    };
  };
  installation: {
    uuid: string;
  };
}

interface Project {
  id: string;
  name: string;
  user_id: string;
  slack_webhook_url?: string;
}

interface AIProvider {
  name: string;
  cost: number;
  execute: (prompt: string, context: any) => Promise<string>;
}

// AI Provider implementations with fallback
const aiProviders: AIProvider[] = [
  {
    name: 'Google Gemini 2.0 Flash',
    cost: 0.0014,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GOOGLE_API_KEY}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          contents: [{ parts: [{ text: `${prompt}\n\nIncident Data:\n${JSON.stringify(context, null, 2)}` }] }],
          generationConfig: {
            temperature: 0.3,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 2048,
          },
          safetySettings: [
            { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
            { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
          ]
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Google Gemini API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
      
      if (!content) {
        throw new Error('No content generated by Gemini');
      }
      
      return content;
    }
  },
  {
    name: 'OpenAI GPT-4o-mini',
    cost: 0.0021,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${OPENAI_API_KEY}`,
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            { role: 'system', content: prompt },
            { role: 'user', content: JSON.stringify(context, null, 2) },
          ],
          max_tokens: 2000,
          temperature: 0.3,
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.choices[0]?.message?.content;
      
      if (!content) {
        throw new Error('No content generated by OpenAI');
      }
      
      return content;
    }
  },
  {
    name: 'Anthropic Claude 3 Haiku',
    cost: 0.00375,
    execute: async (prompt: string, context: any): Promise<string> => {
      const response = await fetch('https://api.anthropic.com/v1/messages', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${ANTHROPIC_API_KEY}`,
          'Content-Type': 'application/json',
          'anthropic-version': '2023-06-01',
        },
        body: JSON.stringify({
          model: 'claude-3-haiku-20240307',
          max_tokens: 2000,
          temperature: 0.3,
          system: prompt,
          messages: [{
            role: 'user',
            content: JSON.stringify(context, null, 2)
          }]
        }),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);
      }

      const data = await response.json();
      const content = data.content?.[0]?.text;
      
      if (!content) {
        throw new Error('No content generated by Claude');
      }
      
      return content;
    }
  }
];

const handler: Handler = async (event: HandlerEvent) => {
  const requestId = Math.random().toString(36).substr(2, 9);
  const startTime = Date.now();

  try {
    // Only handle POST requests
    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers: { 'Allow': 'POST', 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' }),
      };
    }

    // Extract request metadata
    const ipAddress = event.headers['x-forwarded-for'] || event.headers['x-real-ip'] || 'unknown';
    const userAgent = event.headers['user-agent'] || 'unknown';

    // Verify Sentry webhook signature
    const signature = event.headers['x-sentry-hook-signature'];
    if (!signature) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Missing signature' }),
      };
    }

    const body = event.body || '';
    const expectedSignature = createHmac('sha256', SENTRY_WEBHOOK_SECRET)
      .update(body)
      .digest('hex');

    if (signature !== expectedSignature) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid signature' }),
      };
    }

    const webhookData: SentryWebhookEvent = JSON.parse(body);
    
    // Only process issue events
    if (webhookData.action !== 'created' && webhookData.action !== 'resolved') {
      return {
        statusCode: 200,
        body: JSON.stringify({ message: 'Event ignored' }),
      };
    }

    const issue = webhookData.data.issue;

    // Find the project
    const { data: projects, error: projectError } = await supabase
      .from('projects')
      .select('*')
      .order('created_at', { ascending: false });

    if (projectError) {
      console.error('Error fetching projects:', projectError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error' }),
      };
    }

    if (!projects || projects.length === 0) {
      return {
        statusCode: 404,
        body: JSON.stringify({ error: 'No projects configured' }),
      };
    }

    const project: Project = projects[0];

    // Check for existing report (idempotency)
    const { data: existingReport, error: existingError } = await supabase
      .from('reports')
      .select('id, status')
      .eq('project_id', project.id)
      .eq('sentry_issue_id', issue.id)
      .single();

    if (existingError && existingError.code !== 'PGRST116') {
      console.error('Error checking existing report:', existingError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error checking existing report' }),
      };
    }

    if (existingReport) {
      console.log(`Report already exists for issue ${issue.id}, returning existing report ID: ${existingReport.id}`);
      
      if (existingReport.status === 'failed' || existingReport.status === 'processing') {
        console.log(`Restarting processing for existing report ${existingReport.id}`);
        
        const { error: updateError } = await supabase
          .from('reports')
          .update({
            status: 'processing',
            markdown: 'Processing...',
            updated_at: new Date().toISOString()
          })
          .eq('id', existingReport.id);

        if (!updateError) {
          processIncident(project, issue, existingReport.id, requestId).catch(error => {
            console.error('Async processing error:', error);
          });
        }
      }
      
      return {
        statusCode: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          message: 'Report already exists for this issue',
          reportId: existingReport.id,
          status: existingReport.status
        }),
      };
    }

    // Create new report
    const { data: report, error: insertError } = await supabase
      .from('reports')
      .upsert({
        project_id: project.id,
        sentry_issue_id: issue.id,
        title: issue.title,
        markdown: 'Processing...',
        status: 'processing',
      }, { 
        onConflict: 'project_id,sentry_issue_id',
        ignoreDuplicates: false 
      })
      .select()
      .single();

    if (insertError || !report) {
      console.error('Failed to create/update report:', insertError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Failed to create report' }),
      };
    }

    // Process incident asynchronously
    processIncident(project, issue, report.id, requestId).catch(error => {
      console.error('Async processing error:', error);
    });

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        message: 'Webhook received, processing incident',
        reportId: report.id 
      }),
    };

  } catch (error) {
    console.error('Webhook processing error:', error);
    
    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      }),
    };
  }
};

async function processIncident(
  project: Project, 
  issue: any, 
  reportId: number,
  requestId: string
) {
  let status: string = 'processing';
  let markdown = '';
  let algorandTx: string | null = null;
  let audioUrl: string | null = null;
  let usedProvider = '';
  let totalCostCents = 0;

  try {
    console.log(`Processing incident ${issue.id} for project ${project.id}, report ${reportId}`);

    // Step 1: Fetch detailed issue information
    const issueDetails = {
      ...issue,
      events: [],
      tags: [],
      context: {}
    };
    
    // Step 2: Generate markdown with AI fallback
    const aiResult = await generateMarkdownSummaryWithFallback(issueDetails, reportId);
    markdown = aiResult.content;
    usedProvider = aiResult.provider;
    totalCostCents += aiResult.costCents;
    
    console.log(`Generated summary using ${usedProvider} for report ${reportId}`);
    
    // Step 3: Parallel processing for blockchain and audio
    const parallelTasks = [];
    
    // Blockchain anchoring with Nodely
    parallelTasks.push(
      anchorOnAlgorand(markdown, reportId)
        .then(tx => {
          algorandTx = tx;
          totalCostCents += 1; // ~$0.001
        })
        .catch(error => {
          console.error('Blockchain anchoring failed for report', reportId, ':', error);
          status = 'pending_hash';
        })
    );
    
    // Audio generation
    parallelTasks.push(
      generateAudioSummary(markdown, reportId)
        .then(url => {
          audioUrl = url;
          totalCostCents += 15; // ~$0.15 for TTS
        })
        .catch(error => {
          console.error('Audio generation failed for report', reportId, ':', error);
          status = status === 'pending_hash' ? 'partial' : 'text_only';
        })
    );
    
    // Wait for parallel tasks
    await Promise.allSettled(parallelTasks);
    
    // Step 4: Update report
    const finalStatus = status === 'processing' ? 'completed' : status;
    
    const { error: updateError } = await supabase
      .from('reports')
      .update({
        markdown,
        algorand_tx: algorandTx,
        audio_url: audioUrl,
        status: finalStatus,
        updated_at: new Date().toISOString()
      })
      .eq('id', reportId);

    if (updateError) {
      console.error('Error updating report', reportId, ':', updateError);
    }
    
    // Step 5: Send Slack notification (placeholder)
    try {
      await sendSlackNotification(project, issue, markdown, algorandTx, audioUrl, usedProvider, finalStatus, totalCostCents);
      console.log('Slack notification sent for report', reportId);
    } catch (error) {
      console.error('Slack notification failed for report', reportId, ':', error);
    }
    
    console.log(`Successfully processed incident ${issue.id} with status ${finalStatus} for report ${reportId}`);
    
  } catch (error) {
    console.error('Processing failed for report', reportId, ':', error);
    
    // Update report with error status
    await supabase
      .from('reports')
      .update({
        markdown: markdown || `# Processing Failed\n\nAn error occurred while processing this incident:\n\n${error}`,
        status: 'failed',
        updated_at: new Date().toISOString()
      })
      .eq('id', reportId);
  }
}

async function generateMarkdownSummaryWithFallback(
  issueDetails: any, 
  reportId: number
): Promise<{ content: string; provider: string; costCents: number; tokens: number }> {
  const systemPrompt = `You are a senior SRE expert. Transform the following Sentry incident data into a polished post-mortem report in Markdown format. Include:

1. **Executive Summary** - Brief overview of the incident
2. **Timeline of Events** - Chronological sequence of what happened
3. **Root Cause Analysis** - Technical analysis of the underlying cause
4. **Impact Assessment** - User and business impact
5. **Resolution Steps** - What was done to resolve the issue
6. **Action Items for Prevention** - Concrete steps to prevent recurrence

Keep it professional, concise, and actionable. Use proper Markdown formatting with headers, lists, and code blocks where appropriate.`;

  // Try each AI provider in order
  for (let i = 0; i < aiProviders.length; i++) {
    const provider = aiProviders[i];
    
    try {
      console.log(`Attempting to generate summary with ${provider.name} for report ${reportId}`);
      
      const content = await provider.execute(systemPrompt, issueDetails);
      const costCents = Math.round(provider.cost * 100);
      const estimatedTokens = Math.round(content.length / 4); // Rough estimate
      
      console.log(`‚úÖ Successfully generated summary with ${provider.name} for report ${reportId}`);
      return { 
        content, 
        provider: provider.name, 
        costCents,
        tokens: estimatedTokens
      };
      
    } catch (error) {
      console.error(`‚ùå ${provider.name} failed for report ${reportId}:`, error);
      
      if (i === aiProviders.length - 1) {
        throw new Error(`All AI providers failed. Last error from ${provider.name}: ${error}`);
      }
      
      console.log(`üîÑ Falling back to next provider for report ${reportId}...`);
    }
  }
  
  throw new Error('Unexpected error in AI fallback logic');
}

async function anchorOnAlgorand(markdown: string, reportId: number): Promise<string> {
  try {
    // Nodely health check
    const status = await algodClient.status().do();
    console.log(`‚úÖ Nodely algod OK ‚Äì last round ${status['last-round']} for report ${reportId}`);

    // Generate SHA-256 hash
    const encoder = new TextEncoder();
    const data = encoder.encode(markdown);
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

    // Recover account from mnemonic
    const account = algosdk.mnemonicToSecretKey(ALGORAND_MNEMONIC);
    
    // Get suggested transaction parameters
    const suggestedParams = await algodClient.getTransactionParams().do();
    
    // Create transaction
    const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
      from: account.addr,
      to: account.addr,
      amount: 0,
      note: new Uint8Array(Buffer.from(hashHex, 'hex')),
      suggestedParams,
    });

    // Sign and submit
    const signedTxn = txn.signTxn(account.sk);
    const { txId } = await algodClient.sendRawTransaction(signedTxn).do();
    
    // Wait for confirmation
    await algosdk.waitForConfirmation(algodClient, txId, 4);
    
    console.log(`‚úÖ Successfully anchored hash on Algorand via Nodely: ${txId} for report ${reportId}`);
    return txId;
  } catch (error) {
    console.error(`‚ùå Algorand anchoring failed for report ${reportId}:`, error);
    throw error;
  }
}

async function generateAudioSummary(markdown: string, reportId: number): Promise<string> {
  try {
    // Extract text for audio
    const audioText = markdown
      .replace(/#+\s/g, '')
      .replace(/\*\*(.*?)\*\*/g, '$1')
      .replace(/\*(.*?)\*/g, '$1')
      .replace(/```[\s\S]*?```/g, '')
      .split('\n')
      .filter(line => line.trim() && !line.startsWith('- ') && !line.startsWith('*'))
      .slice(0, 10)
      .join('. ')
      .substring(0, 500);

    if (!audioText.trim()) {
      throw new Error('No suitable text found for audio generation');
    }

    // Generate audio
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM/stream`, {
      method: 'POST',
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': ELEVEN_API_KEY,
      },
      body: JSON.stringify({
        text: audioText,
        model_id: 'eleven_monolingual_v1',
        voice_settings: {
          stability: 0.5,
          similarity_boost: 0.5,
        },
      }),
    });

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(`ElevenLabs API error: ${response.status} - ${errorText}`);
    }

    // Upload to storage
    const audioBuffer = await response.arrayBuffer();
    const audioFile = new Uint8Array(audioBuffer);
    
    const fileName = `report_${reportId}_${Date.now()}.mp3`;
    const { data: uploadData, error: uploadError } = await supabase.storage
      .from('audio-summaries')
      .upload(fileName, audioFile, {
        contentType: 'audio/mpeg',
        cacheControl: '3600',
      });

    if (uploadError) {
      throw new Error(`Supabase Storage error: ${uploadError.message}`);
    }

    const { data: urlData } = supabase.storage
      .from('audio-summaries')
      .getPublicUrl(fileName);

    console.log(`‚úÖ Successfully generated audio summary: ${urlData.publicUrl} for report ${reportId}`);
    return urlData.publicUrl;
  } catch (error) {
    console.error(`‚ùå Audio generation failed for report ${reportId}:`, error);
    throw error;
  }
}

async function sendSlackNotification(
  project: Project,
  issue: any,
  markdown: string,
  algorandTx: string | null,
  audioUrl: string | null,
  usedProvider: string,
  status: string,
  costCents: number
) {
  // Placeholder for Slack notification
  console.log(`üì¢ Slack notification for ${project.name}:`, {
    issue: issue.title,
    status,
    provider: usedProvider,
    hasAudio: !!audioUrl,
    hasBlockchain: !!algorandTx,
    cost: `$${(costCents / 100).toFixed(3)}`
  });
}

export { handler };