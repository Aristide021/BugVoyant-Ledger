import type { Handler, HandlerEvent } from '@netlify/functions';
import { createClient } from '@supabase/supabase-js';
import { createHmac } from 'crypto';
import algosdk from 'algosdk';
import { monitoring } from '../../src/lib/monitoring';
import { resilience, RETRY_CONFIGS, CIRCUIT_BREAKER_CONFIGS } from '../../src/lib/resilience';
import { security, DEFAULT_SECURITY_CONFIG } from '../../src/lib/security';
import { slackService } from '../../src/lib/slack';

// Environment variables
const SUPABASE_URL = process.env.VITE_SUPABASE_URL!;
const SUPABASE_SERVICE_ROLE_KEY = process.env.SUPABASE_SERVICE_ROLE_KEY!;
const SENTRY_WEBHOOK_SECRET = process.env.SENTRY_WEBHOOK_SECRET!;
const GOOGLE_API_KEY = process.env.GOOGLE_API_KEY!;
const OPENAI_API_KEY = process.env.OPENAI_API_KEY!;
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY!;
const ELEVEN_API_KEY = process.env.ELEVEN_API_KEY!;
const ALGORAND_TOKEN = process.env.ALGORAND_TOKEN!;
const ALGORAND_SERVER = process.env.ALGORAND_SERVER || 'https://testnet-api.4160.nodely.io';
const ALGORAND_MNEMONIC = process.env.ALGORAND_MNEMONIC!;
const ENCRYPTION_MASTER_KEY = process.env.ENCRYPTION_MASTER_KEY!;

// Initialize Supabase client
const supabase = createClient(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY);

// Initialize Algorand client with Nodely headers
const algodClient = new algosdk.Algodv2(
  { 'X-Algo-api-token': ALGORAND_TOKEN }, // Nodely header format
  ALGORAND_SERVER,
  ''
);

interface SentryWebhookEvent {
  action: string;
  data: {
    issue: {
      id: string;
      title: string;
      culprit: string;
      level: string;
      status: string;
      statusDetails: Record<string, unknown>;
      type: string;
      metadata: Record<string, unknown>;
      numComments: number;
      assignedTo: string | null;
      permalink: string;
      firstSeen: string;
      lastSeen: string;
      count: string;
      userCount: number;
      project: {
        id: string;
        name: string;
        slug: string;
      };
    };
  };
  installation: {
    uuid: string;
  };
}

interface Project {
  id: string;
  name: string;
  user_id: string;
  slack_webhook_url?: string;
}

interface AIProvider {
  name: string;
  cost: number;
  execute: (prompt: string, context: Record<string, unknown>) => Promise<string>;
}

// AI Provider implementations with fallback
const aiProviders: AIProvider[] = [
  {
    name: 'Google Gemini 2.0 Flash',
    cost: 0.0014,
    execute: async (prompt: string, context: Record<string, unknown>): Promise<string> => {
      return resilience.withCircuitBreaker(
        () => resilience.withRetry(
          async () => {
            const response = await resilience.withTimeout(
              () => fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash-exp:generateContent?key=${GOOGLE_API_KEY}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  contents: [{ parts: [{ text: `${prompt}\n\nIncident Data:\n${JSON.stringify(context, null, 2)}` }] }],
                  generationConfig: {
                    temperature: 0.3,
                    topK: 40,
                    topP: 0.95,
                    maxOutputTokens: 2048,
                  },
                  safetySettings: [
                    { category: 'HARM_CATEGORY_HARASSMENT', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_HATE_SPEECH', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_SEXUALLY_EXPLICIT', threshold: 'BLOCK_NONE' },
                    { category: 'HARM_CATEGORY_DANGEROUS_CONTENT', threshold: 'BLOCK_NONE' }
                  ]
                }),
              }),
              30000, // 30 second timeout
              'gemini-api-call'
            );

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Google Gemini API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const content = data.candidates?.[0]?.content?.parts?.[0]?.text;
            
            if (!content) {
              throw new Error('No content generated by Gemini');
            }
            
            return content;
          },
          RETRY_CONFIGS.AI_PROVIDER,
          { operationName: 'gemini-generate' }
        ),
        'gemini',
        CIRCUIT_BREAKER_CONFIGS.AI_PROVIDER
      );
    }
  },
  {
    name: 'OpenAI GPT-4o-mini',
    cost: 0.0021,
    execute: async (prompt: string, context: Record<string, unknown>): Promise<string> => {
      return resilience.withCircuitBreaker(
        () => resilience.withRetry(
          async () => {
            const response = await resilience.withTimeout(
              () => fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${OPENAI_API_KEY}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                  model: 'gpt-4o-mini',
                  messages: [
                    { role: 'system', content: prompt },
                    { role: 'user', content: JSON.stringify(context, null, 2) },
                  ],
                  max_tokens: 2000,
                  temperature: 0.3,
                }),
              }),
              30000,
              'openai-api-call'
            );

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const content = data.choices[0]?.message?.content;
            
            if (!content) {
              throw new Error('No content generated by OpenAI');
            }
            
            return content;
          },
          RETRY_CONFIGS.AI_PROVIDER,
          { operationName: 'openai-generate' }
        ),
        'openai',
        CIRCUIT_BREAKER_CONFIGS.AI_PROVIDER
      );
    }
  },
  {
    name: 'Anthropic Claude 3 Haiku',
    cost: 0.00375,
    execute: async (prompt: string, context: Record<string, unknown>): Promise<string> => {
      return resilience.withCircuitBreaker(
        () => resilience.withRetry(
          async () => {
            const response = await resilience.withTimeout(
              () => fetch('https://api.anthropic.com/v1/messages', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${ANTHROPIC_API_KEY}`,
                  'Content-Type': 'application/json',
                  'anthropic-version': '2023-06-01',
                },
                body: JSON.stringify({
                  model: 'claude-3-haiku-20240307',
                  max_tokens: 2000,
                  temperature: 0.3,
                  system: prompt,
                  messages: [{
                    role: 'user',
                    content: JSON.stringify(context, null, 2)
                  }]
                }),
              }),
              30000,
              'claude-api-call'
            );

            if (!response.ok) {
              const errorText = await response.text();
              throw new Error(`Anthropic API error: ${response.status} - ${errorText}`);
            }

            const data = await response.json();
            const content = data.content?.[0]?.text;
            
            if (!content) {
              throw new Error('No content generated by Claude');
            }
            
            return content;
          },
          RETRY_CONFIGS.AI_PROVIDER,
          { operationName: 'claude-generate' }
        ),
        'claude',
        CIRCUIT_BREAKER_CONFIGS.AI_PROVIDER
      );
    }
  }
];

const handler: Handler = async (event: HandlerEvent) => {
  const requestId = Math.random().toString(36).substr(2, 9);
  const startTime = Date.now();

  try {
    // Only handle POST requests
    if (event.httpMethod !== 'POST') {
      return {
        statusCode: 405,
        headers: { 'Allow': 'POST', 'Content-Type': 'application/json' },
        body: JSON.stringify({ error: 'Method not allowed' }),
      };
    }

    // Extract request metadata
    const ipAddress = event.headers['x-forwarded-for'] || event.headers['x-real-ip'] || 'unknown';
    const userAgent = event.headers['user-agent'] || 'unknown';
    const origin = event.headers['origin'] || event.headers['referer'] || 'unknown';

    // Security validation
    const securityValidation = security.validateWebhookSource(origin, userAgent, DEFAULT_SECURITY_CONFIG);
    if (!securityValidation.valid) {
      await security.logSecurityEvent('unauthorized_access', {
        ipAddress,
        userAgent,
        severity: 'medium',
        description: `Webhook validation failed: ${securityValidation.error}`,
        metadata: { origin, request_id: requestId }
      });

      return {
        statusCode: 403,
        body: JSON.stringify({ error: 'Forbidden' }),
      };
    }

    // Verify Sentry webhook signature
    const signature = event.headers['x-sentry-hook-signature'];
    if (!signature) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Missing signature' }),
      };
    }

    const body = event.body || '';
    const expectedSignature = createHmac('sha256', SENTRY_WEBHOOK_SECRET)
      .update(body)
      .digest('hex');

    if (signature !== expectedSignature) {
      await security.logSecurityEvent('unauthorized_access', {
        ipAddress,
        userAgent,
        severity: 'high',
        description: 'Invalid webhook signature',
        metadata: { request_id: requestId }
      });

      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid signature' }),
      };
    }

    const webhookData: SentryWebhookEvent = JSON.parse(body);
    
    // Only process issue events
    if (webhookData.action !== 'created' && webhookData.action !== 'resolved') {
      return {
        statusCode: 200,
        body: JSON.stringify({ message: 'Event ignored' }),
      };
    }

    const issue = webhookData.data.issue;
    
    // CRITICAL FIX: Find the correct project based on Sentry project information
    // Instead of hardcoding projects[0], match by Sentry org slug or project info
    const sentryOrgSlug = extractOrgSlugFromPermalink(issue.permalink);
    
    // Content validation
    const contentValidation = security.validateContent(
      JSON.stringify(issue), 
      DEFAULT_SECURITY_CONFIG
    );
    
    if (!contentValidation.valid) {
      await security.logSecurityEvent('invalid_content', {
        ipAddress,
        userAgent,
        severity: 'medium',
        description: `Content validation failed: ${contentValidation.error}`,
        metadata: { issue_id: issue.id, request_id: requestId }
      });

      return {
        statusCode: 400,
        body: JSON.stringify({ error: contentValidation.error }),
      };
    }

    // Find the project
    const { data: projects, error: projectError } = await supabase
      .from('projects')
      .select('*')
      .eq('sentry_org_slug', sentryOrgSlug)
      .order('created_at', { ascending: false });

    if (projectError) {
      console.error('Error fetching projects:', projectError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error' }),
      };
    }

    // If no project found for this org, try to find any project (fallback for existing setups)
    let project: Project;
    if (!projects || projects.length === 0) {
      console.warn(`No project found for Sentry org: ${sentryOrgSlug}, trying fallback...`);
      
      const { data: fallbackProjects, error: fallbackError } = await supabase
        .from('projects')
        .select('*')
        .order('created_at', { ascending: false })
        .limit(1);
      
      if (fallbackError || !fallbackProjects || fallbackProjects.length === 0) {
        console.error('No projects configured at all');
        return {
          statusCode: 404,
          body: JSON.stringify({ 
            error: 'No projects configured',
            details: `No project found for Sentry org '${sentryOrgSlug}'. Please ensure your project's Sentry org slug matches the webhook source.`
          }),
        };
      }
      
      project = fallbackProjects[0];
      console.warn(`Using fallback project: ${project.name} for org: ${sentryOrgSlug}`);
    } else {
      project = projects[0];
      console.log(`Found matching project: ${project.name} for org: ${sentryOrgSlug}`);
    }

    // Validate that the project belongs to the correct organization
    if (project.sentry_org_slug && project.sentry_org_slug !== sentryOrgSlug) {
      console.warn(`Project org slug mismatch: expected '${project.sentry_org_slug}', got '${sentryOrgSlug}'`);
      return {
        statusCode: 404,
        body: JSON.stringify({ 
          error: 'Project organization mismatch',
          details: `Webhook from '${sentryOrgSlug}' but project configured for '${project.sentry_org_slug}'`
        }),
      };
    }

    // Check rate limits
    const rateLimitCheck = await security.checkRateLimit(project.user_id, DEFAULT_SECURITY_CONFIG);
    if (!rateLimitCheck.allowed) {
      await security.logSecurityEvent('rate_limit_exceeded', {
        userId: project.user_id,
        projectId: project.id,
        ipAddress,
        userAgent,
        severity: 'medium',
        description: rateLimitCheck.error!,
        metadata: { request_id: requestId }
      });

      return {
        statusCode: 429,
        body: JSON.stringify({ error: rateLimitCheck.error }),
      };
    }

    // Check for existing report (idempotency)
    const { data: existingReport, error: existingError } = await supabase
      .from('reports')
      .select('id, status')
      .eq('project_id', project.id)
      .eq('sentry_issue_id', issue.id)
      .single();

    if (existingError && existingError.code !== 'PGRST116') {
      console.error('Error checking existing report:', existingError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Database error checking existing report' }),
      };
    }

    if (existingReport) {
      console.log(`Report already exists for issue ${issue.id}, returning existing report ID: ${existingReport.id}`);
      
      if (existingReport.status === 'failed' || existingReport.status === 'processing') {
        console.log(`Restarting processing for existing report ${existingReport.id}`);
        
        const { error: updateError } = await supabase
          .from('reports')
          .update({
            status: 'processing',
            markdown: 'Processing...',
            updated_at: new Date().toISOString()
          })
          .eq('id', existingReport.id);

        if (!updateError) {
          processIncident(project, issue, existingReport.id, requestId, ipAddress, userAgent).catch(error => {
            console.error('Async processing error:', error);
          });
        }
      }
      
      return {
        statusCode: 200,
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          message: 'Report already exists for this issue',
          reportId: existingReport.id,
          status: existingReport.status
        }),
      };
    }

    // Create new report
    const { data: report, error: insertError } = await supabase
      .from('reports')
      .upsert({
        project_id: project.id,
        sentry_issue_id: issue.id,
        title: issue.title,
        markdown: 'Processing...',
        status: 'processing',
      }, { 
        onConflict: 'project_id,sentry_issue_id',
        ignoreDuplicates: false 
      })
      .select()
      .single();

    if (insertError || !report) {
      console.error('Failed to create/update report:', insertError);
      return {
        statusCode: 500,
        body: JSON.stringify({ error: 'Failed to create report' }),
      };
    }

    // Log audit event
    await monitoring.logAuditEvent(
      'CREATE',
      'report',
      report.id.toString(),
      undefined,
      { issue_id: issue.id, title: issue.title },
      {
        userId: project.user_id,
        projectId: project.id,
        ipAddress,
        userAgent,
        requestId
      }
    );

    // Process incident asynchronously
    processIncident(project, issue, report.id, requestId, ipAddress, userAgent).catch(error => {
      console.error('Async processing error:', error);
    });

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ 
        message: 'Webhook received, processing incident',
        reportId: report.id 
      }),
    };

  } catch (error) {
    console.error('Webhook processing error:', error);
    
    // Record error metric
    await monitoring.recordSystemMetric('webhook.errors.total', 1, 'counter');
    
    const processingTime = Date.now() - startTime;
    await monitoring.recordSystemMetric('webhook.processing_time', processingTime, 'histogram', { status: 'error' });

    return {
      statusCode: 500,
      body: JSON.stringify({ 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      }),
    };
  }
};

// Helper function to extract org slug from Sentry permalink
function extractOrgSlugFromPermalink(permalink: string): string {
  try {
    // Sentry permalinks format: https://sentry.io/organizations/{org-slug}/issues/{issue-id}/
    const url = new URL(permalink);
    const pathParts = url.pathname.split('/');
    const orgIndex = pathParts.indexOf('organizations');
    
    if (orgIndex !== -1 && pathParts[orgIndex + 1]) {
      return pathParts[orgIndex + 1];
    }
    
    // Fallback: try to extract from hostname if it's a custom domain
    // Format: {org-slug}.sentry.io
    const hostname = url.hostname;
    if (hostname.endsWith('.sentry.io') && hostname !== 'sentry.io') {
      return hostname.split('.')[0];
    }
    
    console.warn('Could not extract org slug from permalink:', permalink);
    return 'unknown';
  } catch (error) {
    console.error('Error parsing Sentry permalink:', error);
    return 'unknown';
  }
}

async function processIncident(
  project: Project, 
  issue: SentryWebhookEvent['data']['issue'], 
  reportId: number,
  requestId: string,
  _ipAddress: string,
  _userAgent: string
) {
  let status: string = 'processing';
  let markdown = '';
  let algorandTx: string | null = null;
  let audioUrl: string | null = null;
  let usedProvider = '';
  let totalCostCents = 0;
  const processingStartTime = Date.now();

  try {
    console.log(`Processing incident ${issue.id} for project ${project.id}, report ${reportId}`);

    // Start monitoring
    monitoring.startStep(reportId, 'fetch_issue_details');
    monitoring.startStep(reportId, 'generate_markdown');

    // Step 1: Fetch detailed issue information
    monitoring.completeStep(reportId, 'fetch_issue_details');
    
    const issueDetails = {
      ...issue,
      events: [],
      tags: [],
      context: {}
    };
    
    // Step 2: Generate markdown with security redaction
    const aiResult = await generateMarkdownSummaryWithFallback(issueDetails, reportId);
    markdown = security.redactSensitiveContent(aiResult.content, DEFAULT_SECURITY_CONFIG);
    usedProvider = aiResult.provider;
    totalCostCents += aiResult.costCents;
    
    monitoring.completeStep(reportId, 'generate_markdown', usedProvider, aiResult.costCents);
    
    // Track AI cost
    await monitoring.trackCost(
      project.user_id,
      project.id,
      {
        serviceType: 'ai_provider',
        providerName: usedProvider.toLowerCase().split(' ')[0],
        costCents: aiResult.costCents,
        usageUnits: aiResult.tokens,
        unitType: 'tokens'
      },
      reportId
    );
    
    console.log(`Generated summary using ${usedProvider} for report ${reportId}`);
    
    // Step 3: Parallel processing for blockchain and audio
    const parallelTasks = [];
    
    // Blockchain anchoring with Nodely
    monitoring.startStep(reportId, 'blockchain_anchoring');
    parallelTasks.push(
      anchorOnAlgorand(markdown, reportId)
        .then(tx => {
          algorandTx = tx;
          monitoring.completeStep(reportId, 'blockchain_anchoring', 'algorand-nodely', 1); // ~$0.001
          return monitoring.trackCost(
            project.user_id,
            project.id,
            {
              serviceType: 'blockchain',
              providerName: 'algorand-nodely',
              costCents: 1,
              usageUnits: 1,
              unitType: 'transactions'
            },
            reportId
          );
        })
        .catch(error => {
          console.error('Blockchain anchoring failed for report', reportId, ':', error);
          monitoring.failStep(reportId, 'blockchain_anchoring', error.message);
          status = 'pending_hash';
        })
    );
    
    // Audio generation
    monitoring.startStep(reportId, 'audio_generation');
    parallelTasks.push(
      generateAudioSummary(markdown, reportId)
        .then(url => {
          audioUrl = url;
          const audioCost = 15; // ~$0.15 for TTS
          totalCostCents += audioCost;
          monitoring.completeStep(reportId, 'audio_generation', 'elevenlabs', audioCost);
          return monitoring.trackCost(
            project.user_id,
            project.id,
            {
              serviceType: 'audio',
              providerName: 'elevenlabs',
              costCents: audioCost,
              usageUnits: markdown.length,
              unitType: 'bytes'
            },
            reportId
          );
        })
        .catch(error => {
          console.error('Audio generation failed for report', reportId, ':', error);
          monitoring.failStep(reportId, 'audio_generation', error.message);
          status = status === 'pending_hash' ? 'partial' : 'text_only';
        })
    );
    
    // Wait for parallel tasks
    await Promise.allSettled(parallelTasks);
    
    // Step 4: Update report
    const finalStatus = status === 'processing' ? 'completed' : status;
    
    const { error: updateError } = await supabase
      .from('reports')
      .update({
        markdown,
        algorand_tx: algorandTx,
        audio_url: audioUrl,
        status: finalStatus,
        updated_at: new Date().toISOString()
      })
      .eq('id', reportId);

    if (updateError) {
      console.error('Error updating report', reportId, ':', updateError);
    }
    
    // Step 5: Send enhanced Slack notifications
    monitoring.startStep(reportId, 'send_notifications');
    try {
      await sendSlackNotification(project, issue, markdown, algorandTx, audioUrl, usedProvider, finalStatus, totalCostCents, Date.now() - processingStartTime);
      monitoring.completeStep(reportId, 'send_notifications', 'slack');
      console.log('Slack notification sent for report', reportId);
    } catch (error) {
      monitoring.failStep(reportId, 'send_notifications', error.message);
      console.error('Slack notification failed for report', reportId, ':', error);
    }
    
    // Log completion
    await monitoring.logAuditEvent(
      'COMPLETE',
      'report',
      reportId.toString(),
      { status: 'processing' },
      { 
        status: finalStatus, 
        provider_used: usedProvider,
        total_cost_cents: totalCostCents,
        has_audio: !!audioUrl,
        has_blockchain_proof: !!algorandTx
      },
      {
        userId: project.user_id,
        projectId: project.id,
        requestId,
        costCents: totalCostCents,
        providerUsed: usedProvider,
        processingTimeMs: Date.now() - processingStartTime
      }
    );
    
    // Record success metrics
    await monitoring.recordSystemMetric('incident.processing.success', 1, 'counter', {
      status: finalStatus,
      provider: usedProvider,
      has_audio: !!audioUrl,
      has_blockchain: !!algorandTx
    });
    
    console.log(`Successfully processed incident ${issue.id} with status ${finalStatus} for report ${reportId}`);
    
    // Cleanup monitoring data
    monitoring.cleanupProcessingData(reportId);
    
  } catch (error) {
    console.error('Processing failed for report', reportId, ':', error);
    
    // Record failure metrics
    await monitoring.recordSystemMetric('incident.processing.failure', 1, 'counter', {
      error: error.message,
      step: 'unknown'
    });
    
    // Update report with error status
    await supabase
      .from('reports')
      .update({
        markdown: markdown || `# Processing Failed\n\nAn error occurred while processing this incident:\n\n${error}`,
        status: 'failed',
        updated_at: new Date().toISOString()
      })
      .eq('id', reportId);

    // Log failure
    await monitoring.logAuditEvent(
      'FAIL',
      'report',
      reportId.toString(),
      { status: 'processing' },
      { 
        status: 'failed',
        error: error.message,
        total_cost_cents: totalCostCents
      },
      {
        userId: project.user_id,
        projectId: project.id,
        requestId,
        costCents: totalCostCents,
        processingTimeMs: Date.now() - processingStartTime
      }
    );
  }
}

async function generateMarkdownSummaryWithFallback(
  issueDetails: Record<string, unknown>, 
  reportId: number
): Promise<{ content: string; provider: string; costCents: number; tokens: number }> {
  const systemPrompt = `You are a senior SRE expert. Transform the following Sentry incident data into a polished post-mortem report in Markdown format. Include:

1. **Executive Summary** - Brief overview of the incident
2. **Timeline of Events** - Chronological sequence of what happened
3. **Root Cause Analysis** - Technical analysis of the underlying cause
4. **Impact Assessment** - User and business impact
5. **Resolution Steps** - What was done to resolve the issue
6. **Action Items for Prevention** - Concrete steps to prevent recurrence

Keep it professional, concise, and actionable. Use proper Markdown formatting with headers, lists, and code blocks where appropriate.`;

  // Try each AI provider in order
  for (let i = 0; i < aiProviders.length; i++) {
    const provider = aiProviders[i];
    
    try {
      console.log(`Attempting to generate summary with ${provider.name} for report ${reportId}`);
      
      const content = await provider.execute(systemPrompt, issueDetails);
      const costCents = Math.round(provider.cost * 100);
      const estimatedTokens = Math.round(content.length / 4); // Rough estimate
      
      console.log(`✅ Successfully generated summary with ${provider.name} for report ${reportId}`);
      return { 
        content, 
        provider: provider.name, 
        costCents,
        tokens: estimatedTokens
      };
      
    } catch (error) {
      console.error(`❌ ${provider.name} failed for report ${reportId}:`, error);
      
      // Record provider failure
      await monitoring.recordSystemMetric(
        `ai_provider.${provider.name.toLowerCase().replace(/\s+/g, '_')}.failure`,
        1,
        'counter',
        { error: error.message }
      );
      
      if (i === aiProviders.length - 1) {
        throw new Error(`All AI providers failed. Last error from ${provider.name}: ${error}`);
      }
      
      console.log(`🔄 Falling back to next provider for report ${reportId}...`);
    }
  }
  
  throw new Error('Unexpected error in AI fallback logic');
}

async function anchorOnAlgorand(markdown: string, reportId: number): Promise<string> {
  return resilience.withCircuitBreaker(
    () => resilience.withRetry(
      async () => {
        // Nodely health check
        try {
          const status = await algodClient.status().do();
          console.log(`✅ Nodely algod OK – last round ${status['last-round']} for report ${reportId}`);
        } catch (error) {
          console.warn(`⚠️ Nodely health check failed for report ${reportId}:`, error);
        }

        // Generate SHA-256 hash
        const encoder = new TextEncoder();
        const data = encoder.encode(markdown);
        const hashBuffer = await crypto.subtle.digest('SHA-256', data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        // Recover account from mnemonic
        const account = algosdk.mnemonicToSecretKey(ALGORAND_MNEMONIC);
        
        // Get suggested transaction parameters
        const suggestedParams = await algodClient.getTransactionParams().do();
        
        // Create transaction
        const txn = algosdk.makePaymentTxnWithSuggestedParamsFromObject({
          from: account.addr,
          to: account.addr,
          amount: 0,
          note: new Uint8Array(Buffer.from(hashHex, 'hex')),
          suggestedParams,
        });

        // Sign and submit
        const signedTxn = txn.signTxn(account.sk);
        const { txId } = await algodClient.sendRawTransaction(signedTxn).do();
        
        // Wait for confirmation
        await algosdk.waitForConfirmation(algodClient, txId, 4);
        
        console.log(`✅ Successfully anchored hash on Algorand via Nodely: ${txId} for report ${reportId}`);
        return txId;
      },
      RETRY_CONFIGS.BLOCKCHAIN,
      { reportId, stepName: 'blockchain_anchoring', operationName: 'algorand-nodely-anchor' }
    ),
    'algorand-nodely',
    CIRCUIT_BREAKER_CONFIGS.BLOCKCHAIN
  );
}

async function generateAudioSummary(markdown: string, reportId: number): Promise<string> {
  return resilience.withCircuitBreaker(
    () => resilience.withRetry(
      async () => {
        // Extract text for audio
        const audioText = markdown
          .replace(/#+\s/g, '')
          .replace(/\*\*(.*?)\*\*/g, '$1')
          .replace(/\*(.*?)\*/g, '$1')
          .replace(/```[\s\S]*?```/g, '')
          .split('\n')
          .filter(line => line.trim() && !line.startsWith('- ') && !line.startsWith('*'))
          .slice(0, 10)
          .join('. ')
          .substring(0, 500);

        if (!audioText.trim()) {
          throw new Error('No suitable text found for audio generation');
        }

        // Generate audio
        const response = await resilience.withTimeout(
          () => fetch(`https://api.elevenlabs.io/v1/text-to-speech/21m00Tcm4TlvDq8ikWAM/stream`, {
            method: 'POST',
            headers: {
              'Accept': 'audio/mpeg',
              'Content-Type': 'application/json',
              'xi-api-key': ELEVEN_API_KEY,
            },
            body: JSON.stringify({
              text: audioText,
              model_id: 'eleven_monolingual_v1',
              voice_settings: {
                stability: 0.5,
                similarity_boost: 0.5,
              },
            }),
          }),
          30000,
          'elevenlabs-tts'
        );

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(`ElevenLabs API error: ${response.status} - ${errorText}`);
        }

        // Upload to storage
        const audioBuffer = await response.arrayBuffer();
        const audioFile = new Uint8Array(audioBuffer);
        
        const fileName = `report_${reportId}_${Date.now()}.mp3`;
        const { data: uploadData, error: uploadError } = await supabase.storage
          .from('audio-summaries')
          .upload(fileName, audioFile, {
            contentType: 'audio/mpeg',
            cacheControl: '3600',
          });

        if (uploadError) {
          throw new Error(`Supabase Storage error: ${uploadError.message}`);
        }

        const { data: urlData } = supabase.storage
          .from('audio-summaries')
          .getPublicUrl(fileName);

        console.log(`✅ Successfully generated audio summary: ${urlData.publicUrl} for report ${reportId}`);
        return urlData.publicUrl;
      },
      RETRY_CONFIGS.AUDIO_GENERATION,
      { reportId, stepName: 'audio_generation', operationName: 'elevenlabs-tts' }
    ),
    'elevenlabs',
    CIRCUIT_BREAKER_CONFIGS.AUDIO_GENERATION
  );
}

async function sendSlackNotification(
  project: Project,
  issue: any,
  markdown: string,
  algorandTx: string | null,
  audioUrl: string | null,
  usedProvider: string,
  status: string,
  costCents: number,
  processingTimeMs: number
) {
  // SECURITY FIX: Get and decrypt Slack webhook URL from encrypted secrets
  try {
    // Get decrypted webhook URL using the server-side master key
    const { data: webhookUrl, error } = await supabase.rpc('get_decrypted_secret', {
      p_project_id: project.id,
      p_secret_type: 'slack_webhook_url',
      p_encryption_key: ENCRYPTION_MASTER_KEY
    });

    if (error || !webhookUrl) {
      console.log('No Slack webhook configured for project', project.id);
      return;
    }

    const notificationData = {
      projectName: project.name,
      issueTitle: issue.title,
      issueUrl: issue.permalink,
      reportId: parseInt(issue.id),
      status,
      provider: usedProvider,
      hasAudio: !!audioUrl,
      hasBlockchainProof: !!algorandTx,
      algorandTx,
      audioUrl,
      processingTime: Math.round(processingTimeMs / 1000),
      costCents
    };

    const result = await slackService.sendIncidentNotification(webhookUrl, notificationData);
    
    if (!result.success) {
      throw new Error(result.error || 'Slack notification failed');
    }

    console.log('✅ Slack notification sent successfully');
  } catch (error) {
    console.error('Slack notification error:', error);
    throw error;
  }
}

export { handler };