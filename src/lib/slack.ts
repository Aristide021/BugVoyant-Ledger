interface SlackMessage {
  text: string;
  blocks?: any[];
  attachments?: any[];
}

interface SlackNotificationData {
  projectName: string;
  issueTitle: string;
  issueUrl: string;
  reportId: number;
  status: string;
  provider: string;
  hasAudio: boolean;
  hasBlockchainProof: boolean;
  algorandTx?: string;
  audioUrl?: string;
  processingTime?: number;
  costCents?: number;
}

export class SlackService {
  private static instance: SlackService;

  private constructor() {}

  static getInstance(): SlackService {
    if (!SlackService.instance) {
      SlackService.instance = new SlackService();
    }
    return SlackService.instance;
  }

  async sendIncidentNotification(
    webhookUrl: string,
    data: SlackNotificationData
  ): Promise<{ success: boolean; error?: string }> {
    try {
      const message = this.buildIncidentMessage(data);
      
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(message),
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Slack API error: ${response.status} - ${errorText}`);
      }

      return { success: true };
    } catch (error) {
      console.error('Slack notification error:', error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  private buildIncidentMessage(data: SlackNotificationData): SlackMessage {
    const statusEmoji = this.getStatusEmoji(data.status);
    const statusColor = this.getStatusColor(data.status);
    
    const blocks = [
      {
        type: 'header',
        text: {
          type: 'plain_text',
          text: `${statusEmoji} Incident Report Generated`,
          emoji: true
        }
      },
      {
        type: 'section',
        fields: [
          {
            type: 'mrkdwn',
            text: `*Project:*\n${data.projectName}`
          },
          {
            type: 'mrkdwn',
            text: `*Status:*\n${data.status.charAt(0).toUpperCase() + data.status.slice(1)}`
          },
          {
            type: 'mrkdwn',
            text: `*AI Provider:*\n${data.provider}`
          },
          {
            type: 'mrkdwn',
            text: `*Report ID:*\n#${data.reportId}`
          }
        ]
      },
      {
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Issue:* <${data.issueUrl}|${data.issueTitle}>`
        }
      }
    ];

    // Add features section
    const features = [];
    if (data.hasAudio) {
      features.push('üéß Audio Summary');
    }
    if (data.hasBlockchainProof) {
      features.push('‚õìÔ∏è Blockchain Anchored');
    }
    features.push(`ü§ñ AI-Generated (${data.provider})`);

    if (features.length > 0) {
      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Features:* ${features.join(' ‚Ä¢ ')}`
        }
      });
    }

    // Add performance metrics if available
    if (data.processingTime || data.costCents) {
      const metrics = [];
      if (data.processingTime) {
        metrics.push(`‚è±Ô∏è ${data.processingTime}s processing`);
      }
      if (data.costCents) {
        metrics.push(`üí∞ $${(data.costCents / 100).toFixed(3)} cost`);
      }

      blocks.push({
        type: 'section',
        text: {
          type: 'mrkdwn',
          text: `*Metrics:* ${metrics.join(' ‚Ä¢ ')}`
        }
      });
    }

    // Add action buttons
    const actions: any[] = [
      {
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'View in Sentry',
          emoji: true
        },
        url: data.issueUrl,
        style: 'primary'
      }
    ];

    if (data.hasBlockchainProof && data.algorandTx) {
      actions.push({
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'Blockchain Proof',
          emoji: true
        },
        url: `https://testnet.explorer.algorand.org/transaction/${data.algorandTx}`,
        style: 'default'
      });
    }

    if (data.hasAudio && data.audioUrl) {
      actions.push({
        type: 'button',
        text: {
          type: 'plain_text',
          text: 'Audio Summary',
          emoji: true
        },
        url: data.audioUrl,
        style: 'default'
      });
    }

    blocks.push({
      type: 'actions',
      elements: actions
    });

    // Add footer
    blocks.push({
      type: 'context',
      elements: [
        {
          type: 'mrkdwn',
          text: `Generated by BugVoyant-Ledger ‚Ä¢ Powered by Nodely Algorand Infrastructure`
        }
      ]
    });

    return {
      text: `${statusEmoji} New incident report generated for ${data.projectName}: ${data.issueTitle}`,
      blocks,
      attachments: [
        {
          color: statusColor,
          fallback: `Incident report generated for ${data.issueTitle}`
        }
      ]
    };
  }

  private getStatusEmoji(status: string): string {
    switch (status) {
      case 'completed':
        return '‚úÖ';
      case 'processing':
        return '‚è≥';
      case 'failed':
        return '‚ùå';
      case 'partial':
        return '‚ö†Ô∏è';
      case 'pending_hash':
        return 'üîÑ';
      case 'text_only':
        return 'üìÑ';
      default:
        return '‚ùì';
    }
  }

  private getStatusColor(status: string): string {
    switch (status) {
      case 'completed':
        return 'good';
      case 'processing':
        return 'warning';
      case 'failed':
        return 'danger';
      case 'partial':
        return 'warning';
      case 'pending_hash':
        return '#439FE0';
      case 'text_only':
        return '#808080';
      default:
        return '#808080';
    }
  }

  async sendTestNotification(webhookUrl: string): Promise<{ success: boolean; error?: string }> {
    const testData: SlackNotificationData = {
      projectName: 'Test Project',
      issueTitle: 'Test Incident - Connection Timeout',
      issueUrl: 'https://sentry.io/issues/test',
      reportId: 12345,
      status: 'completed',
      provider: 'Google Gemini 2.0 Flash',
      hasAudio: true,
      hasBlockchainProof: true,
      algorandTx: 'test-tx-hash',
      audioUrl: 'https://example.com/audio.mp3',
      processingTime: 23,
      costCents: 14
    };

    return this.sendIncidentNotification(webhookUrl, testData);
  }
}

export const slackService = SlackService.getInstance();